{"meta":{"title":"Severin的博客","subtitle":"","description":"","author":"Severin","url":"https://www.severin.xyz","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-28T06:37:46.274Z","updated":"2020-01-28T06:37:46.274Z","comments":true,"path":"404.html","permalink":"https://www.severin.xyz/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-01-28T03:15:02.282Z","updated":"2020-01-28T03:15:02.282Z","comments":true,"path":"categories/index.html","permalink":"https://www.severin.xyz/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-28T03:10:10.789Z","updated":"2020-01-28T03:10:10.789Z","comments":true,"path":"about/index.html","permalink":"https://www.severin.xyz/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-28T03:26:54.831Z","updated":"2020-01-28T03:26:54.831Z","comments":true,"path":"friends/index.html","permalink":"https://www.severin.xyz/friends/index.html","excerpt":"","text":"你可以在评论中留下你的博客名、头像链接和博客链接"},{"title":"","date":"2020-01-28T03:16:40.195Z","updated":"2020-01-28T03:16:40.195Z","comments":true,"path":"mylist/index.html","permalink":"https://www.severin.xyz/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-28T03:16:27.915Z","updated":"2020-01-28T03:16:27.915Z","comments":true,"path":"tags/index.html","permalink":"https://www.severin.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三大查找算法","slug":"三大查找算法","date":"2019-12-20T16:00:00.000Z","updated":"2020-01-30T06:04:15.997Z","comments":true,"path":"2019/12/21/三大查找算法/","link":"","permalink":"https://www.severin.xyz/2019/12/21/%E4%B8%89%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 二分查找 算法思路 已知数组是有序的，假设是升序的，取中间位置的数字与目标数字进行比较，如果相等那么就找到了，如果中间位置大，目标数字就在右边，下一步只用在数组左半部分查找，假如中间的数字小，则目标数字一个在数组的右边，下一步只用在数组右半部查找。 时间复杂度 O(logn) 代码 public class BinarySearch { public static void main(String[] args) { int[] arr={1,2,3,4,5,6,7,8,9}; int search = search(arr, 4); System.out.println(search); } private static int search(int[] arr,int target){ int start=0; int end=arr.length-1; while (start&lt;=end){ int mid=start+(end-start)/2; if (arr[mid]==target){ return mid; }else if (arr[mid]&gt;target){ end=mid-1; }else { start=mid+1; } } return -1; } } 扩展 如果要求找到与某个数字最接近的数字也可以通过二分查找找到。 2. 分块查找也称索引顺序查找 3. 哈希查找 算法思想 哈希查找是通过计算数据元素的存储地址进行查找的一种方法。在插入元素的时候通过hash函数根据键的值计算出插入的下标位置，元素存放在该下标位置的数组中，如果冲突了可以采用拉链法或者开放地址法解决，查找的时候只需根据键计算出插入位置，然后就能查找到元素。 时间复杂度 O(1) 代码 哈希查找算法的实现在于哈希类的实现，哈希的实现有两个关键：一是hash函数如何选择？而是哈希冲突如何解决？这两个问题很可能会问道，建议百度了解，已经可能会提到优化，比如说java1.8的优化。 public class HashSearch { public static void main(String[] args) { Hash hash=new Hash(); hash.put(1,1); hash.put(2,2); hash.put(3,3); System.out.println(hash.get(1)); } } /** * 实现一个简单的哈希类,采用拉链法解决hash冲突 */ class Hash{ private Node[] tables=new Node[10]; public void put(int key,int value){ Node last = getNode(key); if (last!=null){ last.value=value; return; } int index = hash(key); if (tables[index]==null){ tables[index]=new Node(key,value); }else{ Node node = new Node(key, value); node.next=tables[index]; tables[index]=node; } } private Node getNode(int key){ int index = hash(key); if (tables[index]==null){ return null; } Node p=tables[index]; while (p!=null){ if (p.key==key){ return p; } p=p.next; } return null; } public Integer get(int key){ Node node = getNode(key); if (node==null){ return null; } return node.value; } private int hash(int key){ return key%10; } private static class Node{ int key; int value; Node next; public Node(int key, int value) { this.key = key; this.value = value; } } }","categories":[{"name":"经典算法","slug":"经典算法","permalink":"https://www.severin.xyz/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"经典算法/查找","permalink":"https://www.severin.xyz/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.severin.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找","slug":"查找","permalink":"https://www.severin.xyz/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"十大排序算法分析","slug":"十大排序算法分析","date":"2019-12-19T16:00:00.000Z","updated":"2020-01-29T11:08:10.550Z","comments":true,"path":"2019/12/20/十大排序算法分析/","link":"","permalink":"https://www.severin.xyz/2019/12/20/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"排序算法是面试中常问的算法，大厂中排序算法问的深度很深，对排序算法的理解有多个层次 知道常用算法的写法，了解各种算法的时间复杂度，空间复杂度和稳定性 了解每种算法的性能瓶颈 对于每种算法知道如何优化 知道每种算法的应用场景 1. 选择排序 算法思想 将一组数据分为两部分，前面是已排序部分，后面是未排序部分，初始状态可认为位置 0 为已排序部分 (数组下标从0开始)，其余为未排序部分，每一次都从未排序部分选择一个最小元素放在已排序部分的末尾，然后已排序部分增加一个元素，未排序部分减少一个元素，直到数据全部有序。 时间复杂度 选择排序无论数据初始是何种状态，均需要在未排序元素中选择最小或最大元素与未排序序列中的首尾元素交换，因此它的最好、最坏、平均时间复杂度均为 O(n^2)。 空间复杂度 空间复杂度为O(1) 稳定性 直接选择排序是不稳定的。因为每次遍历比较完后会使用本次遍历选择的最小元素和无序区的第一个元素交换位置，所以如果无序区第一个元素后面有相同元素的，则可能会改变相同元素的相对顺序（稳定性：能保证两个相等的数,经过排序之后,其在序列的前后位置顺序不变） 优化思路 每次查找时不仅找出最小值，还找出最大值，分别插到前面和后面，可以减少一半的查询时间。 如果数组元素重复率高，可以考虑使用辅助空间在每一次循环的时候，将本次选择的数及相同元素的索引记录下来，一起处理。 代码 public class SelectionSort { public static void main(String[] args) { int[] arr={1,4,3,2,3,2,1,2,6}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ int minPos=i; for (int j = minPos+1; j &lt; arr.length; j++) { if (arr[j]&lt;arr[minPos]){ minPos=j; } } swap(arr,i,minPos); } } private static void swap(int[] arr,int i,int j){ int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } 2. 冒泡排序 算法思想 通过比较相邻的两个元素，将大的元素或者小的元素交换到后面，这样越大或者越小的元素都会交换到数组的后端。 时间复杂度 时间复杂度是O(n^2) 空间复杂度 空间复杂度为O(1) 稳定性 稳定 优化思路 用一个计数器记录交换的次数，当某一轮交换次数为0则表示数组已经有序，那么就不用继续进行了。 记录最后一次交换的位置，该位置之后没有进行交换说明是有序的了，下一轮只用遍历该位置即可。 代码 public class BubbleSort { public static void main(String[] args) { int[] arr={1,4,23,2,1,1,23,2,1,8}; sort(arr); for (int i=0;i&lt;arr.length;i++){ System.out.print(arr[i]+&quot; &quot;); } } public static void sort(int[] arr){ for (int i=0;i&lt;arr.length-1;i++){ for (int j=0;j&lt;arr.length-i-1;j++){ if (arr[j]&gt;arr[j+1]){ swap(arr,j,j+1); } } } } private static void swap(int[] arr,int i,int j){ int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } 3. (直接)插入排序 算法思想 每趟将一个元素，按照其关键字的大小插入到它前面已经排序的子序列中，依此重复，直到插入全部元素。 时间复杂度 时间复杂度为O(n^2) 空间复杂度 空间复杂度为O(1) 稳定性 稳定 优化思路 希尔排序 二分查找插入排序 二分查找插入排序的原理：是直接插入排序的一个变种，区别是：在有序区中查找新元素插入位置时，为了减少元素比较次数提高效率，采用二分查找算法进行插入位置的确定。 代码 public class InsertionSort { public static void main(String[] args) { int[] arr={1,5,4,3,2,6,7,8,9}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ for (int i=0;i&lt;arr.length;i++){ int temp=arr[i]; int j=i-1; for (;j&gt;=0&amp;&amp;arr[j]&gt;temp;j--){ arr[j+1]=arr[j]; } arr[j+1]=temp; } } } 4. 希尔排序 算法思路 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 时间复杂度 ​ 时间复杂度取决于增量序列的选择O(n^1.3) 空间复杂度 稳定性 不稳定 代码 public class ShellSort { public static void main(String[] args) { int[] arr={1,3,2,4,6,5,7,9,8,0}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int [] arr){ // 增量序列 int[] ds={1,3,7}; for (int i=ds.length-1;i&gt;=0;i--){ insertSort(arr,1); } } /** * 按增量分组进行直接插入排序 * @param arr 数组 * @param d 增量 */ private static void insertSort(int[] arr,int d){ for (int i=0;i&lt;d;i++){ for (int j=i;j&lt;arr.length;j+=d){ int k=j-d; int temp=arr[j]; for (;k&gt;=i&amp;&amp;arr[k]&gt;temp;k-=d){ arr[k+d]=arr[k]; } arr[k+d]=temp; } } } } 5. 堆排序 算法思路 堆是这样一种数据结构，首先堆是一个完全二叉树，其父节点一定大于其所有的子节点。堆排序就是利用堆这种数据结构进行排序，首先构造一个堆，堆顶元素就是最大或最小的元素，把他与堆的最后一个元素交换，这样堆顶元素就调整到了排序后的顺序，而堆的元素个数减少了一个且结构发生了变化，只需要重新调整堆就可以了。循环这个步骤数组就变成有序的了。 时间复杂度 nlogn -&gt; n表示第几轮 logn为调整堆的时间复杂度 空间复杂度 O(1) 稳定性 不稳定 代码 public class HeapSort { public static void main(String[] args) { int[] arr={1,4,3,2,5,7,6,8,9,0}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ // 首先要对整个数组进行heapify操作 for (int i=arr.length/2;i&gt;=0;i--){ heapify(arr,arr.length,i); } for (int i=1;i&lt;=arr.length;i++){ swap(arr,0,arr.length-i); heapify(arr,arr.length-i,0); } } private static void swap(int[] arr,int i,int j){ int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } private static void heapify(int[] arr,int len,int i){ int left=i*2+1; int right=i*2+2; int max=i; if (left&lt;len&amp;&amp;arr[left]&gt;arr[max]){ max=left; } if (right&lt;len&amp;&amp;arr[right]&gt;arr[max]){ max=right; } if (max!=i){ swap(arr,i,max); heapify(arr,len,max); } } } 6. 归并排序 算法思路 基于二路归并算法，将数组分成两个部分，对每一部分递归采取归并排序，这样数组两个部分就排好序了，对于两个已排好序的数组，只需要进行二路归并就可以得到一个有序的数组。 时间复杂度 O(nlogn) 空间复杂度 O(n) 稳定性 稳定 优化思路 原地归并 因为用归并将一个大数组排序时，需要进行多次归并，而且每次归并会都创建一个新数组来存储排序结果会带来问题。由于原地归并排序不需要额外的空间，所以空间复杂度为O(1)。 当递归到规模足够小时，利用插入排序 代码 public class MergeSort { private static int[] tempArr; public static void main(String[] args) { int[] arr={1,2,5,4,3,6,9,7,8,0}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ tempArr=new int[arr.length]; sort(arr,0,arr.length-1); } private static void sort(int[] arr,int start,int end){ if (start==end){ return; } int mid=start+(end-start)/2; sort(arr,start,mid); sort(arr,mid+1,end); merge(arr,start,mid,end); } private static void merge(int[] arr,int start,int mid,int end){ System.arraycopy(arr,0,tempArr,0,arr.length); int i=start; int j=mid+1; int k=start; while (i&lt;=mid&amp;&amp;j&lt;=end){ if (tempArr[i]&lt;tempArr[j]){ arr[k++]=tempArr[i++]; }else{ arr[k++]=tempArr[j++]; } } while (i&lt;=mid){ arr[k++]=tempArr[i++]; } while (j&lt;=end){ arr[k++]=tempArr[j++]; } } } 7. 快速排序 算法思路 快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。具体步骤是选择一个元素作为基准元素，将比它小的元素放置在它的左边，将比它大的元素排它的后面，这样基准元素的位置就确定了，然后分别对基准元素左边和右边的序列进行相同操作，每次都能将一个元素排放到正确的位置。 时间复杂度 O(nlogn) 递归的过程O(n) partition过程O(n)-&gt;O(nlogn) 空间复杂度 空间复杂度为logn 优化思路 代码 public class QuickSort { public static void main(String[] args) { int[] arr={1,4,2,3,6,5,7,9,8,0}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ quickSort(arr,0,arr.length-1); } private static void quickSort(int[] arr,int start,int end){ if (start&gt;=end){ return; } int pos=partition(arr,start,end); quickSort(arr,start,pos-1); quickSort(arr,pos+1,end); } private static int partition(int[] arr,int start,int end){ int left=start-1; int k=start; while (k&lt;=end){ if(arr[k]&gt;arr[start]){ k++; }else{ swap(arr,++left,k++); } } swap(arr,start,left); return left; } private static void swap(int[] arr,int i,int j){ int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } 8. 桶排序 算法思路 这是一种算法思想，基于非比较的排序算法，时间复杂度比较低但是一般需要额外的空间，将数组中的元素分配到不同的桶，桶与桶之间是有顺序的，桶的内部元素无序，对每个不为空的桶进行排序（可以使用别的排序算法），然后将不为空的桶中的元素进行输出就可以完成排序。 代码 public class BucketSort { public static void main(String[] args) { int[] arr={1,3,2,5,4,6,9,8,7,0}; sort(arr); for (int i : arr) { System.out.printf(i+&quot; &quot;); } } public static void sort(int[] arr){ int max=arr[0]; int min=arr[0]; for (int value : arr) { min = Math.min(value, min); max = Math.max(value, max); } ArrayList&lt;Integer&gt;[] buckets=new ArrayList[max/10-min/10+1]; for (int i=0;i&lt;buckets.length;i++){ buckets[i]=new ArrayList&lt;Integer&gt;(); } for (int value : arr) { buckets[(value-min)/10].add(value); } for (int i=0;i&lt;buckets.length;i++){ if (buckets[i].size()!=0){ Collections.sort(buckets[i]); } } int k=0; for (int i=0;i&lt;buckets.length;i++){ if (buckets[i].size()!=0){ for (int j=0;j&lt;buckets[i].size();j++){ arr[k++]=buckets[i].get(j); } } } } } 9. 基数排序 算法思想 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。是桶排序思想的一种。是一种多关键字排序。 代码 public class RadixSort { public static void main(String[] args) { int[] arr={123,43,231,24,56,432,124}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } public static void sort(int[] arr){ int[] result=new int[arr.length]; int[] count=new int[10]; int maxLen=maxLen(arr); // 分别对十位，个位，百位......进行排序 for (int i=0;i&lt;=maxLen;i++){ int temp= (int) Math.pow(10,i); for (int value : arr) { count[value / temp % 10]++; } for (int j=1;j&lt;count.length;j++){ count[j]+=count[j-1]; } for (int j=arr.length-1;j&gt;=0;j--){ result[--count[arr[j]/temp%10]]=arr[j]; } System.arraycopy(result,0,arr,0,arr.length); Arrays.fill(count,0); } } private static int maxLen(int[] arr){ int max=arr[0]; for (int i : arr) { max=Math.max(i,max); } int len=0; while (max!=0){ max/=10; len++; } return len; } } 10. 计数排序 算法思路 准备一个桶，桶的长度为n，且待排序数组的范围都在0到n-1之间，这样数组中的数i就可以放入桶的第i项，桶只要记住每个数字出现的次数，然后扫描桶就可以得到排序后的序列，适合数组范围不大的元素。 代码 public class CountSort { public static void main(String[] args) { int[] arr={1,3,2,4,5,6,8,7,9,0}; sort(arr); for (int i : arr) { System.out.print(i+&quot; &quot;); } } private static void sort(int[] arr){ int[] count=new int[10];// 计数数组，数组的数的范围落在0-count.length-1 for (int value : arr) { count[value]++; } int k=0; for (int i=0;i&lt;count.length;i++){ while (count[i]&gt;0){ count[i]--; arr[k++]=i; } } } } 11. 常用排序一览表 12. 常见面试问题总结 告诉你某种算法，比如很明确的问你某种算法然后不断追问，如快速排序（字节跳动一面） 说一下快速排序的思想（先考你知不知道思想） 快速排序的时间复杂度/空间复杂度/稳定(考一下你会不会分析算法或者说这个算法是不是你背下来的实际上你并不知道或不理解) 快速排序不适合什么样的数据（考你某种算法的缺点，进一步看你理不理解这个算法） 如果要排上面的算法，怎么优化（基于某个问题，要求你进行优化，这类问题最深应该就问到这一步了，后面也问不下去了） 不明确告诉你某种算法，问你排某一类特征的数据应该用什么算法排序(字节跳动一面) 这类问题难在要逆向思考，你得对所有算法都得足够的熟悉 问题：排一组比较有序的数组用什么算法，为什么可以用这种算法 13.一些其他排序算法 置换选择排序 枚举排序 14. 总结 一共有四种不稳定的排序算法，选择排序，堆排序，希尔排序，快速排序，其他的都是稳定的排序。 数据的特征大概有：数据基本有序，数据范围不大，数据逆序 分析数据的时间复杂度必须知道他的循环嵌套关系，以及每层循环的时间复杂度，优化也是这么思考的，看每一层循环这么优化 空间复杂度比较好分析，但是注意递归的情况，比如快速排序的空间时间复杂度不是O(1)而是logn(上面的表示错误的) 要理解算法的稳定性有什么影响，不稳定为什么不好？","categories":[{"name":"经典算法","slug":"经典算法","permalink":"https://www.severin.xyz/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"经典算法/排序","permalink":"https://www.severin.xyz/categories/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.severin.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://www.severin.xyz/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"java虚拟机问题总结","slug":"java虚拟机问题总结","date":"2019-12-18T16:00:00.000Z","updated":"2020-01-29T02:53:11.142Z","comments":true,"path":"2019/12/19/java虚拟机问题总结/","link":"","permalink":"https://www.severin.xyz/2019/12/19/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"java虚拟机问题总结一. 自动内存管理机制1. java虚拟机运行时数据区有哪些，各自的功能 程序计数器 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 java堆 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，由于栈上分配、标量替换技术的存在，对象不一定都在堆中分配。 方法区 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虚拟机栈 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 本地方法栈 本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 2. 永久代和元空间的概念在JDK1.8之前方法区被称为“永久代”，原因是当时将方法区划分出一块永久代来实现方法区，这样垃圾收集器就可以像管理java堆来管理方法区，而到了jdk1.8，则是使用本地空间实现的元空间来代替永久代。 3. 什么是运行时常量池，存放什么运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 4.什么是直接内存，有什么用直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 在JDK 1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存限制。 5. 对象是如何创建的 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。 在类加载检查通过后，接下来虚拟机将为新生对象分配内存 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 6.对象在内存中是怎样分配的一个对象在内存中由三部分组成：对象头，实例数据，对齐填充。 HotSpot虚拟机的对象头包括两部分信息组成，第一部分用于存储对象自身的运行时数据，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 7. 对象分配的方式 指针碰撞（非线程安全） 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。 CAS同步处理（线程安全） 对分配内存空间的动作进行同步处理，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。 TALB（线程安全） 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。 8. 如何定位到一个对象，这些方法有什么优点和缺点有两种方式，一种是直接指针访问，一种是对象句柄访问。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，对象引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。直接指针访问，对象引用存放了对象的真实地址。直接指针引用的优点是定位快，但是缺点是，当对象移动时需要修改对象引用的内容，句柄访问的缺点是需要两次定位才能找到对象，但是优点是对象移动，不需要改变对象引用的内容。使用句柄访问的方式更加常见。 9. JVM中可能发生的OOM的情况什么是OOM，OOM的全称是OutOfMemory，当申请的内存太大，java虚拟机无法满足我们的时候就会抛出OOM异常。 java运行时数据区只有程序计数器不会发生OOM，其他区域都有可能发生OOM 方法区OOM java堆OOM 虚拟方法栈OOM 本地方法栈OOM 本机直接内存OOM 10. 如何确定哪些内存需要回收主要两种方法，一种是引用计数算法，一种是可达性分析算法。 引用计数算法：对象都拥有一个计数器，当有一个地方引用该对象则计数器加1,引用失效就减1，当计数器的值为0的时候，这个对象就需要被回收 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 11. 哪些对象可以作为GC ROOT基本上就是java代码可以写出来的对象引用 虚拟机栈中的对象（本地变量） 方法区静态属性引用的对象(静态变量) 方法区中常量引用的对象（常量） 本地方法栈中JNI(native方法)引用的对象 12. 引用有哪些类型 强引用 强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 软引用 软引用是用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常 弱引用 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知 13. finalize方法的作用一个对象被标记为不可达的时候，并不意味着一定会回收这个对象，还需要经过一次筛选，筛选的条件是这个对象的finalize方法是否有必要执行。。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行“。当一个对象被判断有必要执行，会把这个对象放置在一个做作F-QUEUE的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果在finalize方法中重新把这个对象赋到对象引用链中，这个对象就不会被回收。 14. 方法区是否会被回收，回收的内容是什么，什么时候需要回收方法区java虚拟机规范中没有定义必须回收方法区，并且回收方法区的收益非常低。主要回收两部分内容：废弃常量和无用的类。一个无用的类是指：该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 15. 有哪些垃圾收集算法 标记清除算法 最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 标记清除算法可能会造成大量的内存碎片 标记整理算法 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这种方法的缺点就是浪费了空间。 s实际上：将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。 分代收集算法 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 16. Partial GC、Minor GC、Major GC、Mixed GC、Full GC 名词 含义 Partial GC 不是完整收集整个Java堆的垃圾收集，分为：Minor GC，Major GC和Mixed GC Minor GC 指目标只是新生代的垃圾收集，Young GC Major GC 指目标只是老年代的垃圾收集，Old GC，这个概念有点资料指整堆收集 Mixed GC 指目标是收集整个新生代以及部分老年代的垃圾收集。目前G1收集器会有这种行为 Full GC 收集整个Java堆和方法区的垃圾收集。 17. Remember Set通常将java堆划分为不同的区域，每次只对一个区域进行回收。假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题提出了跨代引用假说，即跨代引用相对于同代引用来说仅占极少数。基于这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，RememberedSet），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。 18. 什么是OopMap采用可达性分析算法来识别需要回收的对象，通常第一步是进行GC-Roots的枚举（也就是在整个内存中把Gc-roots找出来），但是在整片内存中查找符合要求的对象引用需要扫描内存，这个步骤是非常耗时间的，并且枚举根节点需要在一个不变的内存快照中进行，所以会先阻塞所有用户线程的执行，因此如果花大量的时间进行枚举根节点，程序会进行长时间的停顿，这一点是无法让用户接受的。为了解决这个问题，我们使用了OopMap这种数据结构，一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接从得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。 OopMap是一种数据结构，利用它可以解决枚举根节点长时间停顿的问题。 19. 什么是安全点虽然OopMap解决了枚举根节点的时间问题，但是程序运行时，引用关系是变化的，因此每一条指令都可能生成新的OopMap，这样的话内存中需要存放许多OopMap，占用大量的额外空间，安全点就是来解决引入OopMap带来的空间消耗问题的。 安全点的思想是不在每一条指令生成OopMap，而只在特定的指令生成OopMap，这些指令的位置就是安全点，程序执行时，只有在安全点才会停顿下来开始GC。 安全点的选定会带来一些问题，如果安全点选的太少，会让两次GC的等待时间太长，太频繁会导致工作线程经常停顿，增大运行时的负荷。因此安全点的选取必须遵循一个特定的原则，真实情况下，所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定，比如方法调用，循环跳转，异常跳转等。 但是还有一个问题，如何保证GC时所有的线程都停顿在安全点位置，有两种方式，一种是抢先式中断，一种是主动式中断。 抢先式中断式先把所有线程中断，对于没有在安全点中断的线程恢复其执行，直到它运行到安全点。 当GC需要中断线程的时候，不直接对线程操作，会在安全点位置设置标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 20. 什么是安全区域安全区域解决了安全点没有解决的问题，比如安全点机制下，如果某个线程处于阻塞状态或者放弃了CPU，那么该线程无法响应JVM的中断请求。 安全区域是指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意位置开始GC都是安全的。 当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。 21. 你知道哪些垃圾收集器 Serial、Serial Old Serial收集器是一个单线程的收集器，当它进行垃圾收集时，必须暂停其他所有的工作线程，然后启动一个收集线程进行垃圾收集，直到它收集结束。Serial Old是老年版本 Serial作用于新生代使用复制算法，Serial Old作用于老年代使用标记整理算法。 Serial如此简单，并且会引发STW，它的应用场景是什么 简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代，垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。 ParNew ParNew收集器其实就是Serial收集器的多线程版本，新生代使用复制算法，老年代使用标记整理算法。除了Serial收集器外，目前只有它能与CMS收集器配合工作。 Parallel Scavenge Parallel Scavenge收集器是一个新生代收集器，使用复制算法，是并行的多线程收集器。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数 Parallel Old Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 CMS CMS收集器是一种以获取最短回收停顿时间为目标的收集器，它的优点是并发收集、低停顿； 它的缺点是对处理器资源很敏感，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。CMS收集器无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“StopThe World”的Full GC的产生。基于标记清除算法，收集结束时会有大量空间碎片产生。 什么是浮动垃圾 在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。 G1 Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。 G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。 更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。 22. CMS收集器的工作过程 初始标记 标记GC-ROOTS可以直接引用的对象，会停顿工作线程，但是速度很快 并发标记 进行GC ROOTS track的过程，找到引用链其他对象，花费的时间相对长，但是可以与工作线程并发执行 重新标记 重新标记由于并发标记过程中引用关系发生变化的那部分对象，会停顿工作线程 并发清除 并发清除垃圾 23. G1收集器的工作过程 初始标记 并发标记 再次标记 筛选回收 24. CMS与G1的对比与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。 内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间； 目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间 25. 有哪些低延迟垃圾收集器Shenandoah、ZGC 26. 对象分配要遵循哪些策略 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 大对象直接进入老年代 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。 动态对象年龄判定 27. 如何判断对象的年龄为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 28. 什么是内存分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 二. 虚拟机执行子系统1. 什么是java的平台无关性和语言无关性平台无关性是指java代码可以不经过任何修改在不同的操作系统中运行，平台无关性是通过java虚拟机将物理硬件的区别和实际操作系统的系统调用细节屏蔽实现的，对于java来说看到的java虚拟机是一样的。语言无关性是指java虚拟机运行的是Class文件，至于这个Class文件是怎么产生的，由什么语言产生的都无所谓，只要符合虚拟机规范都可以运行。 2. 说一下Class文件的结构《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾 魔数 魔数的作用是确定这个文件是否是一个能被虚拟机接受的Class文件，魔数为CAFEBABE Class的版本号 版本号由次版本号和主板本号组成，虚拟机必须拒绝执行超过其版本号的Class文件。 常量池 紧接着主次版本号之后的是常量池入口，常量池中主要存放两大类常量：字面量和符号引用。 访问标志 这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 类索引、父类索引和接口索引集合 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名 字段表集合 字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 方法表集合 属性表集合 3. 类加载时机 遇到new、getStatic、setStatic、invokeStatic指令时 反射调用时 子类加载时，如果父类没有被加载则会先加载父类 main方法所在的类会在虚拟机启动时加载 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。 4. 类加载的过程 加载 类加载的时机（有且仅有五个） 遇到new、getStatic、setStatic、invokeStatic指令时 反射调用时 子类加载时，如果父类没有被加载则会先加载父类 main方法所在的类会在虚拟机启动时加载 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。 加载需要完成的事情 通过类的全限定名获取这个类的二进制字节流 将这个二进制流代表的静态存储结构转化成运行时数据结构 在内存中生成一个java.lang.Class对象（虽然是对象，但是在hotspot中放到方法区），作为方法区这个类的各种数据的访问入口 可以从什么地方获取二进制字节流 各种zip包，比如jar包，war包，ear包等 网络中，典型应用是Applet 运行时计算生成，如动态代理 其他文件生成，如jsp 数据库中获取 数组类的加载 数组类不是由类加载器去加载的，而是虚拟机创建的 数组类的元素类型需要类加载器加载 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类 型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型 的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与 引导类加载器关联。 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类 的可见性将默认为public。 验证 验证的目的 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段的检验动作 文件格式验证 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。 包括魔数检验，版本号检验等…… 元数据验证 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。 字节码验证 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 包括： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被 当前类访问。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 解析 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程 初始化 初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程 5. 有哪些类加载器 6. 什么是双亲委派模型 类加载器之间的这种层次关系，称为类加载器的双亲委派模型。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 9. 双亲委派模型的好处使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 10. 如何实现自定义类加载器只需要继承ClassLoader，并覆盖findClass方法。在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载。 11. 有哪些破坏双亲委派模型的例子 第一次被破坏是双亲委派出现之前 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换 12. 栈帧存放了什么局部变量表、操作数栈、动态链接和方法返回地址 13. 局部变量表存放什么局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位 14. 操作数栈的运行过程当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。 15. 动态链接是什么每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接","categories":[{"name":"java进阶","slug":"java进阶","permalink":"https://www.severin.xyz/categories/java%E8%BF%9B%E9%98%B6/"},{"name":"java虚拟机","slug":"java进阶/java虚拟机","permalink":"https://www.severin.xyz/categories/java%E8%BF%9B%E9%98%B6/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://www.severin.xyz/tags/jvm/"},{"name":"java","slug":"java","permalink":"https://www.severin.xyz/tags/java/"},{"name":"总结","slug":"总结","permalink":"https://www.severin.xyz/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"探究java虚拟机：垃圾收集器总结","slug":"探究java虚拟机：垃圾收集器总结","date":"2019-12-18T16:00:00.000Z","updated":"2020-01-30T05:59:43.714Z","comments":true,"path":"2019/12/19/探究java虚拟机：垃圾收集器总结/","link":"","permalink":"https://www.severin.xyz/2019/12/19/%E6%8E%A2%E7%A9%B6java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"一. 经典的垃圾收集器特点总结 1. Serial收集器Serial收集器的工作方式是停止所有正在运行的用户线程，然后启动一个线程进行垃圾收集。它工作在新生代，使用复制算法。特点是简单高效，没有额外的内存开销，并且没有线程切换开销。适合客户端场景和微服务等管理内存小的场景。 2. ParNew收集器ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其他和Serial收集器一样。它的特点是除了Serial收集器外，目前只有它能与CMS收集器配合工作。但是也是HotSpot虚拟机第一款退出历史舞台的垃圾收集器。 ParNew收集器在单核心处理器的环境不比Serial收集器性能好，甚至由于存在线程交互的开销，该收集器在某些时候不能超越Serial收集器。 随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同。 3. Parallel Scavenge收集器Parallel Scavenge收集器作用于新生代，使用复制算法，采用多线程进行垃圾收集，与ParNew收集器类似，但是不同的地方是，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（吞吐量是指CPU处理用户代码的时间与总CPU时间的之比）。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。 4. Serial Old收集器Serial收集器的老年版本，使用标记整理算法，作用于老年代，其他特性与Serial收集器一样。 5. Parallel Old收集器Parallel Scavenge收集器的老年版本，基于标记整理算法实现。它的意义是使得新生代和老年代都可以达到一个可控制的吞吐量的目标。 6. CMS收集器作用于老年代，使用标记清除算法，是第一个真正可以与用户工作线程并发执行的垃圾收集器，目标是获取最短回收停顿时间。它的优点是并发收集和低停顿。缺点是对CPU资源敏感，无法清除浮动垃圾，会产生大量的内存碎片。 CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。 工作流程如下： 初始标记 仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，会发生STW。 并发标记 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。 并发清除 清理删除掉标记阶段判断的已经死亡的对象，由于采用标记清除算法不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。 7. G1收集器G1收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，它不再按照新生代和老年代的方式划分堆，而是将堆划分成相等大小的区域（Region），G1收集器会跟踪每一个区域的回收价值，即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，默认的回收策略是优先回收价值大的区域。Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 工作过程如下： 初始标记 仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。需要停顿工作线程。 并发标记 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。 重新标记对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 筛选回收 负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。 二. 低延迟垃圾收集器衡量一款垃圾收集器的标准有：内存占用、吞吐量、延迟。垃圾收集器很难同时实现三个标准，但是随着计算机硬件的发展，内存占用和吞吐量逐渐变得不是问题，内存价格的下降使得不在过分关注内存占用问题，CPU性能的提高使得吞吐量提高，但是延迟问题无法通过计算机硬件的进步解决，比如说回收1TB的内存花费的时间自然要比回收1GB的内存的时间长。Shenandoah和ZGC都是低延迟的垃圾收集器，它们都可以在任意可管理的（譬如现在ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒的目标。 1. Shenandoah收集器Shenandoah收集器不是由Oracle开发的“官方“垃圾收集器，它是由RedHat公司开发的新型收集器项目，现在已经贡献给OpenJDK 12，并且成为OpenJDK 12的新特性。它的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。 Shenandoah更像是G1的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码。 Shenandoah相比起G1的改进主要有三点： 支持并发的整理算法 不会有专门的新生代Region或者老年代Region的存在，没有实现分代 Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率 工作过程： 初始标记 与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。 并发标记 与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。 最终标记 与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。 并发清理 这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region。 并发回收 把回收集里面的存活对象先复制一份到其他未被使用的Region之中，并发运行，此时工作线程的引用会发生变化，会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。 初始引用更新 并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。 并发引用更新 真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。 最终引用更新 修正存在于GC Roots中的引用 并发清理 经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成ImmediateGarbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。 转发指针 转发指针是实现对象移动与用户程序并发的一种解决方案。 此前，要做类似的并发操作，通常是在被移动对象原有的内存上设置保护陷阱，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。虽然确实能够实现对象移动与用户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价是非常大的，不能频繁使用。 新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。使用时只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。 转发指针与某些早期Java虚拟机使用过的句柄定位有一些相似之处，两者都是一种间接性的对象访问方式，差别是句柄通常会统一存储在专门的句柄池中，而转发指针是分散存放在每一个对象头前面。 2. ZGC收集器ZGC是jdk 11的新特性，由Oracle公司研发，目标是在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。 ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器 ZGC的内存布局与Shenandoah和G1一样，也采用基于Region的堆内存布局，但不同的是，ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量 小型Region：容量固定为2MB，用于放置小于256KB的小对象。 中型Region：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。 大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象 染色指针 染色指针是一种直接将少量额外的信息存储在指针上的技术，因为操作系统寻址的时候并不需要用到指针上的所有位，那么剩下的位就可以存一些信息。染色指针直接将引用的信息记录在引用中，这样一个对象是否存活只与其引用有关，与对象本身无关，这样即使对象移动了，也能知道一个引用是否需要重置。 工作过程 并发标记 与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，但是ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。 并发预备重分配 统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集。 ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的 并发重分配 把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。 因为染色指针技术，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”能力。 染色指针带来的好处： 只有第一次访问旧对象会陷入转发，也就是额外的开销只有一次 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，旧指针一旦被使用，它们都是可以自愈的 并发重映射 重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。 参考：《深入理解java虚拟机：JVM高级特性与最佳实践（第三版）》周志明","categories":[{"name":"java进阶","slug":"java进阶","permalink":"https://www.severin.xyz/categories/java%E8%BF%9B%E9%98%B6/"},{"name":"java虚拟机","slug":"java进阶/java虚拟机","permalink":"https://www.severin.xyz/categories/java%E8%BF%9B%E9%98%B6/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://www.severin.xyz/tags/jvm/"},{"name":"java","slug":"java","permalink":"https://www.severin.xyz/tags/java/"},{"name":"总结","slug":"总结","permalink":"https://www.severin.xyz/tags/%E6%80%BB%E7%BB%93/"}]}]}