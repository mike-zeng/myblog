{"meta":{"title":"Severin的博客","subtitle":"","description":"","author":"Severin","url":"https://www.severin.xyz","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-28T03:14:10.750Z","updated":"2020-01-28T03:14:10.750Z","comments":true,"path":"404.html","permalink":"https://www.severin.xyz/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-01-28T03:15:02.282Z","updated":"2020-01-28T03:15:02.282Z","comments":true,"path":"categories/index.html","permalink":"https://www.severin.xyz/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-28T03:10:10.789Z","updated":"2020-01-28T03:10:10.789Z","comments":true,"path":"about/index.html","permalink":"https://www.severin.xyz/about/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-28T03:26:54.831Z","updated":"2020-01-28T03:26:54.831Z","comments":true,"path":"friends/index.html","permalink":"https://www.severin.xyz/friends/index.html","excerpt":"","text":"你可以在评论中留下你的博客名、头像链接和博客链接"},{"title":"所有标签","date":"2020-01-28T03:16:27.915Z","updated":"2020-01-28T03:16:27.915Z","comments":true,"path":"tags/index.html","permalink":"https://www.severin.xyz/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-01-28T03:16:40.195Z","updated":"2020-01-28T03:16:40.195Z","comments":true,"path":"mylist/index.html","permalink":"https://www.severin.xyz/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"java虚拟机问题总结","slug":"java虚拟机问题总结","date":"2020-01-27T12:06:52.213Z","updated":"2020-01-20T12:46:23.163Z","comments":true,"path":"2020/01/27/java虚拟机问题总结/","link":"","permalink":"https://www.severin.xyz/2020/01/27/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"java虚拟机复习一. 自动内存管理机制1. java虚拟机运行时数据区有哪些，各自的功能 程序计数器 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 java堆 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 方法区 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虚拟机栈 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 本地方法栈 本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 2. 什么是运行时常量池，存放什么运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 3.什么是直接内存，有什么用直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 在JDK 1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存限制。 4. 对象是如何创建的 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。 在类加载检查通过后，接下来虚拟机将为新生对象分配内存 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 5.对象在内存中是怎样分配的一个对象在内存中由三部分组成：对象头，实例数据，对齐填充。 HotSpot虚拟机的对象头包括两部分信息组成，第一部分用于存储对象自身的运行时数据，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 6. 如何定位到一个对象，这些方法有什么优点和缺点有两种方式，一种是直接指针访问，一种是对象句柄访问。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，对象引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。直接指针访问，对象引用存放了对象的真实地址。直接指针引用的优点是定位快，但是缺点是，当对象移动时需要修改对象引用的内容，句柄访问的缺点是需要两次定位才能找到对象，但是优点是对象移动，不需要改变对象引用的内容。 7. JVM中可能发生的OOM的情况https://juejin.im/post/5dc6bf65f265da4d4a306e81 什么是OOM，OOM的全称是OutOfMemory，当申请的内存太大，java虚拟机无法满足我们的时候就会抛出OOM异常。 java运行时数据区只有程序计数器不会发生OOM，其他区域都有可能发生OOM 方法区OOM java堆OOM 虚拟方法栈OOM 本地方法栈OOM 本机直接内存OOM 8. 如何确定哪些内存需要回收主要两种方法，一种是引用计数算法，一种是可达性分析算法。 引用计数算法：对象都拥有一个计数器，当有一个地方引用该对象则计数器加1,引用失效就减1，当计数器的值为0的时候，这个对象就需要被回收 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 9. 哪些对象可以作为GC ROOT基本上就是java代码可以写出来的对象引用 虚拟机栈中的对象（本地变量） 方法区静态属性引用的对象(静态变量) 方法区中常量引用的对象（常量） 本地方法栈中JNI(native方法)引用的对象 10. 引用有哪些类型 强引用 强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 软引用 软引用是用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常 弱引用 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知 11. finalize方法的作用一个对象被标记为不可达的时候，并不意味着一定会回收这个对象，还需要经过一次筛选，筛选的条件是这个对象的finalize方法是否有必要执行。。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行“。当一个对象被判断有必要执行，会把这个对象放置在一个做作F-QUEUE的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果在finalize方法中重新把这个对象赋到对象引用链中，这个对象就不会被回收。 12. 方法区是否会被回收，回收的内容是什么，什么时候需要回收方法区java虚拟机规范中没有定义必须回收方法区，并且回收方法区的收益非常低。主要回收两部分内容：废弃常量和无用的类。一个无用的类是指：该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 13. 有哪些垃圾收集算法 标记清除算法 最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 标记清除算法可能会造成大量的内存碎片 标记整理算法 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这种方法的缺点就是浪费了空间。 s实际上：将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。 分代收集算法 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 14. 什么是OopMap采用可达性分析算法来识别需要回收的对象，通常第一步是进行GC-Roots的枚举（也就是在整个内存中把Gc-roots找出来），但是在整片内存中查找符合要求的对象引用需要扫描内存，这个步骤是非常耗时间的，并且枚举根节点需要在一个不变的内存快照中进行，所以会先阻塞所有用户线程的执行，因此如果花大量的时间进行枚举根节点，程序会进行长时间的停顿，这一点是无法让用户接受的。为了解决这个问题，我们使用了OopMap这种数据结构，他的特点是OopMap中记录了某个偏移量的对象的数据类型，这样在枚举根节点的时候就不需要遍历内存，只需要根据OopMap直接定位到对象的数据类型，采用这种方式的GC称为准确式GC。 OopMap是一种数据结构，利用他可以解决枚举根节点长时间停顿的问题 15. 什么是安全点虽然OopMap解决了枚举根节点的时间问题，但是程序运行时，引用关系是变化的，因此每一条指令都可能生成新的OopMap，这样的话内存中需要存放许多OopMap，占用大量的额外空间，安全点就是来解决引入OopMap带来的空间消耗问题的。 安全点的思想是不在每一条指令生成OopMap，而只在特定的指令生成OopMap，这些指令的位置就是安全点，程序执行时，只有在安全点才会停顿下来开始GC。 安全点的选定会带来一些问题，如果安全点选的太少，会让两次GC的等待时间太长，太频繁会导致工作线程经常停顿，增大运行时的负荷。因此安全点的选取必须遵循一个特定的原则，真实情况下，所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定，比如方法调用，循环跳转，异常跳转等。 但是还有一个问题，如何保证GC时所有的线程都停顿在安全点位置，有两种方式，一种是抢先式中断，一种是主动式中断。 抢先式中断式先把所有线程中断，对于没有在安全点中断的线程恢复其执行，直到它运行到安全点。 当GC需要中断线程的时候，不直接对线程操作，会在安全点位置设置标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 16. 什么是安全区域安全区域解决了安全点没有解决的问题，比如安全点机制下，如果某个线程处于阻塞状态或者放弃了CPU，那么该线程无法响应JVM的中断请求。 安全区域是指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意位置开始GC都是安全的。 当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。 17. 你知道哪些垃圾收集器 Serial、Serial Old 这个收集器是一个单线程的收集器，的它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 有两个版本，一个作用于新生代，一个作用于老年代，作用于新生代使用复制算法，老年代使用标记整理算法。 ParNew ParNew收集器其实就是Serial收集器的多线程版本，新生代使用复制算法，老年代使用标记整理算法。除了Serial收集器外，目前只有它能与CMS收集器配合工作。 Parallel Scavenge Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，是并行的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Old Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 CMS CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器 G1 18. CMS收集器的工作过程 初始标记 并发标记 重新标记 并发清除 19. G1收集器的工作过程 初始标记 并发标记 再次标记 筛选回收 20. 现在有哪些新的垃圾收集器，特点是什么，怎么工作的ZGC 21. 对象分配要遵循哪些策略 对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 大对象直接进入老年代 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。 22. 如何判断对象的年龄为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 23. 什么是内存分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 二. 虚拟机执行子系统1. 什么是java的平台无关性和语言无关性平台无关性是指java代码可以不经过任何修改在不同的操作系统中运行，平台无关性是通过java虚拟机将物理硬件的区别和实际操作系统的系统调用细节屏蔽实现的，对于java来说看到的java虚拟机是一样的。语言无关性是指java虚拟机运行的是Class文件，至于这个Class文件是怎么产生的，由什么语言产生的都无所谓，只要符合虚拟机规范都可以运行。 2. 说一下Class文件的结构 魔数、Class的版本号 魔数的作用是确定这个文件是否是一个能被虚拟机接受的Class文件。版本号由次版本号和主板本号组成，虚拟机必须拒绝执行超过其版本号的Class文件。 常量池 紧接着主次版本号之后的是常量池入口，常量池中主要存放两大类常量：字面量和符号引用。 访问标志 这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 类索引、父类索引和接口索引集合 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名 字段表集合 字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 方法表集合 属性表集合 3. 类加载时机 遇到new、getStatic、setStatic、invokeStatic指令时 反射调用时 子类加载时，如果父类没有被加载则会先加载父类 main方法所在的类会在虚拟机启动时加载 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。 4. 类加载的过程 加载 类加载的时机（有且仅有五个） 遇到new、getStatic、setStatic、invokeStatic指令时 反射调用时 子类加载时，如果父类没有被加载则会先加载父类 main方法所在的类会在虚拟机启动时加载 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。 加载需要完成的事情 通过类的全限定名获取这个类的二进制字节流 将这个二进制流代表的静态存储结构转化成运行时数据结构 在内存中生成一个java.lang.Class对象（虽然是对象，但是在hotspot中放到方法区），作为方法区这个类的各种数据的访问入口 可以从什么地方获取二进制字节流 各种zip包，比如jar包，war包，ear包等 网络中，典型应用是Applet 运行时计算生成，如动态代理 其他文件生成，如jsp 数据库中获取 数组类的加载 数组类不是由类加载器去加载的，而是虚拟机创建的 数组类的元素类型需要类加载器加载 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类 型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型 的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与 引导类加载器关联。 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类 的可见性将默认为public。 验证 验证的目的 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段的检验动作 文件格式验证 保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。 包括魔数检验，版本号检验等…… 元数据验证 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。 字节码验证 对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 包括： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被 当前类访问。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 解析 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程 初始化 初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程 5. 有哪些类加载器 6. 什么是双亲委派模型 类加载器之间的这种层次关系，称为类加载器的双亲委派模型。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 9. 双亲委派模型的好处使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 10. 如何实现自定义类加载器只需要继承ClassLoader，并覆盖findClass方法。在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载 11. 有哪些破坏双亲委派模型的例子 第一次被破坏是双亲委派出现之前 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换 12. 栈帧存放了什么局部变量表、操作数栈、动态链接和方法返回地址 13. 局部变量表存放什么局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位 14. 操作数栈的运行过程当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。 15. 动态链接是什么每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 三. Java内存模型","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-27T11:12:05.815Z","updated":"2020-01-27T11:12:05.815Z","comments":true,"path":"2020/01/27/hello-world/","link":"","permalink":"https://www.severin.xyz/2020/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}