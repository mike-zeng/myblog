---
sidebar: [grid, toc, tags] # 放置任何你想要显示的侧边栏部件
categories: [java进阶, java虚拟机]
date: 2019-12-19
tags:
- jvm
- java
- 总结
---

### java虚拟机问题总结

#### 一. 自动内存管理机制

##### 1. java虚拟机运行时数据区有哪些，各自的功能

- 程序计数器

  程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的**行号指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

- java堆

  此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存，由于栈上分配、标量替换技术的存在，**对象不一定都在堆中分配**。

- 方法区

  用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。

- 虚拟机栈

  每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个**方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程**。

- 本地方法栈

  本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。

  ![](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20200128195246.png)
  
  



##### 2. 永久代和元空间的概念

在JDK1.8之前方法区被称为“永久代”，原因是当时将方法区划分出一块永久代来实现方法区，这样垃圾收集器就可以像管理java堆来管理方法区，而到了jdk1.8，则是使用本地空间实现的元空间来代替永久代。



##### 3. 什么是运行时常量池，存放什么

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的**各种字面量**和**符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。



##### 4.什么是直接内存，有什么用

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

在JDK 1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存限制。



##### 5. 对象是如何创建的

- 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。

- 在类加载检查通过后，接下来虚拟机将为新生对象分配内存

- 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值

- 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

- 执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

  

##### 6.对象在内存中是怎样分配的

一个对象在内存中由三部分组成：**对象头**，**实例数据**，**对齐填充**。

- HotSpot虚拟机的对象头包括两部分信息组成，第一部分用于存储对象自身的运行时数据，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

- 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

- 对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

  

##### 7. 对象分配的方式

- 指针碰撞（非线程安全）

  假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。

- CAS同步处理（线程安全）

  对分配内存空间的动作进行同步处理，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

- TALB（线程安全）

  把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。



##### 8. 如何定位到一个对象，这些方法有什么优点和缺点

有两种方式，一种是**直接指针访问**，一种是**对象句柄访问**。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，对象引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。直接指针访问，对象引用存放了对象的真实地址。直接指针引用的优点是定位快，但是缺点是，当对象移动时需要修改对象引用的内容，句柄访问的缺点是需要两次定位才能找到对象，但是优点是对象移动，不需要改变对象引用的内容。**使用句柄访问的方式更加常见**。



##### 9. JVM中可能发生的OOM的情况

什么是OOM，OOM的全称是OutOfMemory，当申请的内存太大，java虚拟机无法满足我们的时候就会抛出OOM异常。

java运行时数据区**只有程序计数器不会发生OOM，其他区域都有可能发生OOM**

- 方法区OOM
- java堆OOM
- 虚拟方法栈OOM
- 本地方法栈OOM
- 本机直接内存OOM



##### 10. 如何确定哪些内存需要回收

主要两种方法，一种是**引用计数算法**，一种是**可达性分析算法**。

- 引用计数算法：对象都拥有一个计数器，当有一个地方引用该对象则计数器加1,引用失效就减1，当计数器的值为0的时候，这个对象就需要被回收

- 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

  

##### 11. 哪些对象可以作为GC ROOT

基本上就是java代码可以写出来的对象引用

- 虚拟机栈中的对象（本地变量）
- 方法区静态属性引用的对象(静态变量)
- 方法区中常量引用的对象（常量）
- 本地方法栈中JNI(native方法)引用的对象



##### 12. 引用有哪些类型

- 强引用

  强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

- 软引用

  软引用是用来描述一些还有用但并非必需的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常

- 弱引用

  弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。

- 虚引用

  虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知



##### 13. finalize方法的作用

一个对象被标记为不可达的时候，并不意味着一定会回收这个对象，还需要经过一次筛选，筛选的条件是这个对象的finalize方法是否有必要执行。。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行“。当一个对象被判断有必要执行，会把这个对象放置在一个做作F-QUEUE的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。如果在finalize方法中重新把这个对象赋到对象引用链中，这个对象就不会被回收。



##### 14. 方法区是否会被回收，回收的内容是什么，什么时候需要回收方法区

java虚拟机规范中没有定义必须回收方法区，并且回收方法区的收益非常低。主要回收两部分内容：**废弃常量**和**无用的类**。一个无用的类是指：该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



##### 15. 有哪些垃圾收集算法

- 标记清除算法

  最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

  标记清除算法可能会造成大量的内存碎片

- 标记整理算法

  标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

- 复制算法

  将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着
  的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

  这种方法的缺点就是浪费了空间。

  s实际上：将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。

- 分代收集算法

  这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

##### 16. Partial GC、Minor GC、Major GC、Mixed GC、Full GC

| 名词       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| Partial GC | 不是完整收集整个Java堆的垃圾收集，分为：Minor GC，Major GC和Mixed GC |
| Minor GC   | 指目标只是新生代的垃圾收集，Young GC                         |
| Major GC   | 指目标只是老年代的垃圾收集，Old GC，这个概念有点资料指整堆收集 |
| Mixed GC   | 指目标是收集整个新生代以及部分老年代的垃圾收集。目前G1收集器会有这种行为 |
| Full GC    | 收集整个Java堆和方法区的垃圾收集。                           |

##### 17. Remember Set

通常将java堆划分为不同的区域，每次只对一个区域进行回收。假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑**会为内存回收带来很大的性能负担**。为了解决这个问题提出了跨代引用假说，即跨代引用相对于同代引用来说仅占极少数。基于这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，RememberedSet），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

##### 18. 什么是OopMap

采用可达性分析算法来识别需要回收的对象，通常第一步是进行GC-Roots的枚举（也就是在整个内存中把Gc-roots找出来），但是在整片内存中查找符合要求的对象引用需要扫描内存，这个步骤是非常耗时间的，并且枚举根节点需要在一个不变的内存快照中进行，所以会先阻塞所有用户线程的执行，因此如果花大量的时间进行枚举根节点，程序会进行长时间的停顿，这一点是无法让用户接受的。为了解决这个问题，我们使用了OopMap这种数据结构，一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接从得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

OopMap是一种数据结构，利用它可以解决枚举根节点长时间停顿的问题。



##### 19. 什么是安全点

虽然OopMap解决了枚举根节点的时间问题，但是程序运行时，引用关系是变化的，因此每一条指令都可能生成新的OopMap，这样的话内存中需要存放许多OopMap，占用大量的额外空间，安全点就是来解决引入OopMap带来的空间消耗问题的。

安全点的思想是不在每一条指令生成OopMap，而只在特定的指令生成OopMap，这些指令的位置就是安全点，程序执行时，只有在安全点才会停顿下来开始GC。

安全点的选定会带来一些问题，如果安全点选的太少，会让两次GC的等待时间太长，太频繁会导致工作线程经常停顿，增大运行时的负荷。因此安全点的选取必须遵循一个特定的原则，真实情况下，所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定，比如方法调用，循环跳转，异常跳转等。

但是还有一个问题，如何保证GC时所有的线程都停顿在安全点位置，有两种方式，一种是抢先式中断，一种是主动式中断。

- 抢先式中断式先把所有线程中断，对于没有在安全点中断的线程恢复其执行，直到它运行到安全点。

- 当GC需要中断线程的时候，不直接对线程操作，会在安全点位置设置标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

  

##### 20. 什么是安全区域

安全区域解决了安全点没有解决的问题，比如安全点机制下，如果某个线程处于阻塞状态或者放弃了CPU，那么该线程无法响应JVM的中断请求。

安全区域是指在一段代码片段中，引用关系不会发生改变，在这个区域中的任意位置开始GC都是安全的。

当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。



##### 21. 你知道哪些垃圾收集器

![image-20200120144239677](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20200120144239677.png)

- Serial、Serial Old

  Serial收集器是一个单线程的收集器，当它进行垃圾收集时，必须暂停其他所有的工作线程，然后启动一个收集线程进行垃圾收集，直到它收集结束。Serial Old是老年版本

  **Serial作用于新生代使用复制算法，Serial Old作用于老年代使用标记整理算法。**

  - **Serial如此简单，并且会引发STW，它的应用场景是什么**

    简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外**内存消耗最小**的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于**没有线程交互的开销**，专心做垃圾收集自然可以获得最高的单线程收集效率。在**用户桌面的应用场景**以及近年来流行的**部分微服务应用**中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代，垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。

- ParNew

  ParNew收集器其实就是Serial收集器的多线程版本，新生代使用复制算法，老年代使用标记整理算法。**除了Serial收集器外，目前只有它能与CMS收集器配合工作**。

- Parallel Scavenge

  Parallel Scavenge收集器是一个新生代收集器，使用复制算法，是并行的多线程收集器。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

  Parallel Scavenge收集器提供了**两个参数用于精确控制吞吐量**，分别是控制**最大垃圾收集停顿时间**的-XX：MaxGCPauseMillis参数以及**直接设置吞吐量大小**的-XX：GCTimeRatio参数

- Parallel Old

  Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

- CMS

  CMS收集器是一种以获取最短回收停顿时间为目标的收集器，它的优点是**并发收集、低停顿**；

  它的缺点是**对处理器资源很敏感**，在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。CMS收集器**无法处理“浮动垃圾”**，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“StopThe World”的Full GC的产生。基于标记清除算法，收集结束时**会有大量空间碎片产生**。

  - **什么是浮动垃圾**

    在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。

- G1

  Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和**基于Region的内存布局**形式。
  
  G1不再坚持固定大小以及固定数量的分代区域划分，而是**把连续的Java堆划分为多个大小相等的独立区域**，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。
  
  更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。

##### 22. CMS收集器的工作过程

- 初始标记

  标记GC-ROOTS可以直接引用的对象，会停顿工作线程，但是速度很快

- 并发标记

  进行GC ROOTS track的过程，找到引用链其他对象，花费的时间相对长，但是可以与工作线程并发执行

- 重新标记

  重新标记由于并发标记过程中引用关系发生变化的那部分对象，会停顿工作线程

- 并发清除

  并发清除垃圾

##### 23. G1收集器的工作过程

- 初始标记

- 并发标记

- 再次标记

- 筛选回收

  

##### 24. CMS与G1的对比

与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着**G1运作期间不会产生内存空间碎片**，垃圾收集完成之后能提供规整的可用内存。

内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致**G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间**；

目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间



##### 25. 有哪些低延迟垃圾收集器

Shenandoah、ZGC



##### 26. 对象分配要遵循哪些策略

- 对象优先在Eden分配

  大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟
  机将发起一次Minor GC。

- 大对象直接进入老年代

- 长期存活的对象将进入老年代

  既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。

- 动态对象年龄判定

  

##### 27. 如何判断对象的年龄

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。



##### 28. 什么是内存分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。



***

#### 二. 虚拟机执行子系统

##### 1. 什么是java的平台无关性和语言无关性

平台无关性是指java代码可以不经过任何修改在不同的操作系统中运行，平台无关性是通过java虚拟机将物理硬件的区别和实际操作系统的系统调用细节屏蔽实现的，对于java来说看到的java虚拟机是一样的。语言无关性是指java虚拟机运行的是Class文件，至于这个Class文件是怎么产生的，由什么语言产生的都无所谓，只要符合虚拟机规范都可以运行。

![](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20200129103320.png)

##### 2. 说一下Class文件的结构

《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。

**无符号数**属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值

**表**是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾

- 魔数

  魔数的作用是确定这个文件是否是一个能被虚拟机接受的Class文件，魔数为CAFEBABE

- Class的版本号

  版本号由次版本号和主板本号组成，虚拟机必须拒绝执行超过其版本号的Class文件。

- 常量池

  紧接着主次版本号之后的是常量池入口，常量池中主要存放两大类常量：**字面量**和**符号引用**。

- 访问标志

  这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

- 类索引、父类索引和接口索引集合

  类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名

- 字段表集合

  字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

- 方法表集合

- 属性表集合

  

##### 3. 类加载时机

1. 遇到new、getStatic、setStatic、invokeStatic指令时

2. 反射调用时

3. 子类加载时，如果父类没有被加载则会先加载父类

4. main方法所在的类会在虚拟机启动时加载

5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。

   

##### 4. 类加载的过程

- 加载

  - 类加载的时机（有且仅有五个）
    1. 遇到new、getStatic、setStatic、invokeStatic指令时
    2. 反射调用时
    3. 子类加载时，如果父类没有被加载则会先加载父类
    4. main方法所在的类会在虚拟机启动时加载
    5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄 所对应的类没有进行过初始化，则需要先触发其初始化。
  - 加载需要完成的事情
    1. 通过类的全限定名获取这个类的二进制字节流
    2. 将这个二进制流代表的静态存储结构转化成运行时数据结构
    3. 在内存中生成一个java.lang.Class对象（虽然是对象，但是在hotspot中放到方法区），作为方法区这个类的各种数据的访问入口
  - 可以从什么地方获取二进制字节流
    - 各种zip包，比如jar包，war包，ear包等
    - 网络中，典型应用是Applet
    - 运行时计算生成，如动态代理
    - 其他文件生成，如jsp
    - 数据库中获取
  - 数组类的加载
    - 数组类不是由类加载器去加载的，而是虚拟机创建的
    - 数组类的元素类型需要类加载器加载
    - 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类 型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型 的类加载器的类名称空间上被标识
    - 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与 引导类加载器关联。
    - 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类 的可见性将默认为public。

- 验证

  - 验证的目的

    确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

  - 验证阶段的检验动作

    - 文件格式验证

      保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。

      包括魔数检验，版本号检验等......

    - 元数据验证

      对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。

    - 字节码验证

      对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。

    - 符号引用验证

      发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

      包括：

      - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
      - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
      - 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被 当前类访问。

- 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

- 解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

- 初始化

  初始化阶段是执行类构造器\<clinit\>()方法的过程
  
  

##### 5. 有哪些类加载器

![image-20200120200132139](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20200120200132139.png)



##### 6. 什么是双亲委派模型

- 类加载器之间的这种层次关系，称为类加载器的双亲委派模型。

- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。

- 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

  

##### 9. 双亲委派模型的好处

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。



##### 10. 如何实现自定义类加载器

只需要继承ClassLoader，并覆盖findClass方法。在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载。



##### 11. 有哪些破坏双亲委派模型的例子

- 第一次被破坏是双亲委派出现之前

- 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办

- 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换

  

##### 12. 栈帧存放了什么

局部变量表、操作数栈、动态链接和方法返回地址



##### 13. 局部变量表存放什么

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位



##### 14. 操作数栈的运行过程

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。



##### 15. 动态链接是什么

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接



