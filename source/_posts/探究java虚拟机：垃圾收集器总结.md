---
title: 探究java虚拟机：垃圾收集器总结
sidebar: [grid, toc, tags]
categories: [java进阶, java虚拟机]
date: 2019-12-19
tags:
- jvm
- java
- 总结
---

#### 一. 经典的垃圾收集器特点总结



![](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/%E6%8E%A2%E7%A9%B6java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20200129113418.png)

##### 1. Serial收集器

Serial收集器的工作方式是停止所有正在运行的用户线程，然后启动一个线程进行垃圾收集。它工作在新生代，使用复制算法。特点是简单高效，没有额外的内存开销，并且没有线程切换开销。适合客户端场景和微服务等管理内存小的场景。



##### 2. ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其他和Serial收集器一样。它的特点是除了Serial收集器外，目前只有它能与CMS收集器配合工作。但是也是HotSpot虚拟机第一款退出历史舞台的垃圾收集器。

ParNew收集器在单核心处理器的环境不比Serial收集器性能好，甚至由于存在线程交互的开销，该收集器在某些时候不能超越Serial收集器。

随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同。



##### 3. Parallel Scavenge收集器

Parallel Scavenge收集器作用于新生代，使用复制算法，采用多线程进行垃圾收集，与ParNew收集器类似，但是不同的地方是，Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（吞吐量是指CPU处理用户代码的时间与总CPU时间的之比）。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。



##### 4. Serial Old收集器

Serial收集器的老年版本，使用标记整理算法，作用于老年代，其他特性与Serial收集器一样。



##### 5. Parallel Old收集器

Parallel Scavenge收集器的老年版本，基于标记整理算法实现。它的意义是使得新生代和老年代都可以达到一个可控制的吞吐量的目标。



##### 6. CMS收集器

作用于老年代，使用标记清除算法，是第一个真正可以与用户工作线程并发执行的垃圾收集器，目标是获取最短回收停顿时间。它的优点是并发收集和低停顿。缺点是对CPU资源敏感，无法清除浮动垃圾，会产生大量的内存碎片。

CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。

工作流程如下：

- 初始标记

  仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，会发生STW。

- 并发标记

  从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

- 重新标记

  为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

- 并发清除

  清理删除掉标记阶段判断的已经死亡的对象，由于采用标记清除算法不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

  

##### 7. G1收集器

G1收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，它不再按照新生代和老年代的方式划分堆，而是将堆划分成相等大小的区域（Region），G1收集器会跟踪每一个区域的回收价值，即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，默认的回收策略是优先回收价值大的区域。Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。

工作过程如下：

- 初始标记

  仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。需要停顿工作线程。

- 并发标记

  从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

- 重新标记
  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

- 筛选回收

  负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

***

#### 二. 低延迟垃圾收集器

衡量一款垃圾收集器的标准有：内存占用、吞吐量、延迟。垃圾收集器很难同时实现三个标准，但是随着计算机硬件的发展，内存占用和吞吐量逐渐变得不是问题，内存价格的下降使得不在过分关注内存占用问题，CPU性能的提高使得吞吐量提高，但是延迟问题无法通过计算机硬件的进步解决，比如说回收1TB的内存花费的时间自然要比回收1GB的内存的时间长。Shenandoah和ZGC都是低延迟的垃圾收集器，它们都可以在任意可管理的（譬如现在ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒的目标。

##### 1. Shenandoah收集器

Shenandoah收集器不是由Oracle开发的“官方“垃圾收集器，它是由RedHat公司开发的新型收集器项目，现在已经贡献给OpenJDK 12，并且成为OpenJDK 12的新特性。它的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。

Shenandoah更像是G1的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码。

**Shenandoah相比起G1的改进主要有三点**：

- 支持并发的整理算法
- 不会有专门的新生代Region或者老年代Region的存在，没有实现分代
- Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率

**工作过程**：

- 初始标记

  与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。

- 并发标记

  与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。

- 最终标记

  与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。

- 并发清理

  这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region。

- 并发回收

  把回收集里面的存活对象先复制一份到其他未被使用的Region之中，并发运行，此时工作线程的引用会发生变化，会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。

- 初始引用更新

  并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。

- 并发引用更新

  真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。

- 最终引用更新

  修正存在于GC Roots中的引用

- 并发清理

  经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成ImmediateGarbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。

**转发指针**

转发指针是实现对象移动与用户程序并发的一种解决方案。

此前，要做类似的并发操作，通常是在被移动对象原有的内存上设置保护陷阱，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。虽然确实能够实现对象移动与用户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价是非常大的，不能频繁使用。

新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。使用时只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。

转发指针与某些早期Java虚拟机使用过的句柄定位有一些相似之处，两者都是一种间接性的对象访问方式，差别是句柄通常会统一存储在专门的句柄池中，而转发指针是分散存放在每一个对象头前面。

##### 2. ZGC收集器

ZGC是jdk 11的新特性，由Oracle公司研发，目标是在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器

ZGC的内存布局与Shenandoah和G1一样，也采用基于Region的堆内存布局，但不同的是，ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量

- 小型Region：容量固定为2MB，用于放置小于256KB的小对象。
- 中型Region：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。
- 大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象

**染色指针**

染色指针是一种直接将少量额外的信息存储在指针上的技术，因为操作系统寻址的时候并不需要用到指针上的所有位，那么剩下的位就可以存一些信息。染色指针直接将引用的信息记录在引用中，这样一个对象是否存活只与其引用有关，与对象本身无关，这样即使对象移动了，也能知道一个引用是否需要重置。

**工作过程**

- 并发标记

  与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，但是ZGC的**标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位**。

- 并发预备重分配

  统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集。

  ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对全堆的

- 并发重分配

  把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表，记录从旧对象到新对象的转向关系。

  因为染色指针技术，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”能力。

  染色指针带来的好处：

  - 只有第一次访问旧对象会陷入转发，也就是额外的开销只有一次
  - 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，旧指针一旦被使用，它们都是可以自愈的

- 并发重映射

  重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。

***

*参考：《深入理解java虚拟机：JVM高级特性与最佳实践（第三版）》周志明*

