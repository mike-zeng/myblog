---
title: Redis基础知识总结
sidebar: [grid, toc, tags] # 放置任何你想要显示的侧边栏部件
categories: [数据库, redis]
date: 2019-12-28
tags:
- 数据库
- redis
- 总结
---



#### 1. 初识Redis

https://zhuanlan.zhihu.com/p/42272979

**1. Redis有哪些特性**

首先**Redis的速度非常快**，并且**Redis支持多种数据结构**，还**提供了许多丰富的功能**如提供了键过期的功能，发布订阅功能，支持Lua脚本等功能；**Redis简单稳定**，源码非常简洁；**支持的客户端语言很多**；**支持持久化**，发生断电不会丢失数据；提供了**主从复制的功能**；提供了**集群的功能**，适合分布式环境

**2. Redis为什么快**

1. **完全基于内存**，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2. **数据结构简单，对数据操作也简单**，Redis中的数据结构是专门进行设计的；

3. 采用**单线程，避免了不必要的上下文切换和竞争条件**，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. **使用多路I/O复用模型，非阻塞IO**；

5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

**3. Redis有哪些应用场景**

- 缓存

  redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略，适合作为缓存。

- 排行榜系统

  Redis提供类表和有序集合数据结构，方便实现各种排行榜

- 计数器应用

  Redis天然支持计数功能且性能非常好。

- 社交网络

  redis可以很方便的实现点赞，共同好友等功能

- 消息队列系统

  Redis提供了发布订阅功能和阻塞队列的功能

**4. Redis不适合什么样的应用**

使用Redis，基于成本考虑，最大的问题是内存的价格比较昂贵，而Redis将数据全部放在内存中，而基于内存又提供了快速访问的能力，如果一个应用中的数据量比较大并且不需要经常访问就不适合使用Redis来存放这些量大且冷门的数据。

***

#### 2. Redis的数据结构

***

#### 3. 小功能大用处

**1. Redis命令执行的生命周期是怎样的**

发送命令->命令排队->命令执行->返回结果

**2. 如何统计执行比较慢的命令**

通过参数来设置慢查询阈值，执行时间超过这个阈值的命令就会被记录下来，使用`slowlog`命令就可以获取到慢查询日志。

**3. 什么是pipeline机制**

在redis中某些操作提供了批量操作的命令，但是许多操作是没有对应的批量操作的命令，所以在执行一批大量的命令时，总的执行包括真正的执行时间以及发送命令和接受响应的往返时间，往返时间取决于网络的状况，为了降低网络时延的影响，pipeline提供了将一组命令组合在一起发送给服务端的能力，这样就只有一次往返时间，提高了命令执行的效率。

**4. redis对事务的支持情况**

redis只支持简单的事务，这种事务不具备完整的ACID特性，使用事务的时候执行`multi`开启事务，后面的命令都在同一个事务中，使用`exec`来提交事务或者使用`exec`命令来取消事务，如果事务中的操作中有命令语法错误了整个事务将无法执行，但是redis的事务是不支付撤销的，在某些场景下可以使用类似乐观锁的机制来确保事务中的key没有被其他客户端修改过。

**5. Lua语言在Redis中扮演的角色**

Lua语言是一门由C语言实现的脚本语言，在Redis可以通过lua语言实现自定义的命令。

**6. 介绍一下Redis的Bitmaps**

bitmaps是一种数据结构，叫做位图，他的基本单位是二进制位，每个位只能取0或者1。在Redis中为bitmaps提供了许多位操作的功能，并且bitmap本身在redis中不是一种独立的数据结构，他的底层是字符串，因为bitmaps的基本单元是二进制位，所以数据结构占用的空间很小，适合那些只需要统计两种状态且要求空间很少的应用，比如说统计一亿用户中每天的活跃用户。

**7. 介绍一下HyperLogLog**

HyperlogLog的底层是字符串类型，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，但是统计值不是完全精确的，具有一定的误差，官方给出的失误率是0.81%。redis中实现的HyperLogLog，只需要12K内存，在标准误差0.81%的前提下，能够统计`2^64`个数据。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。

**8. Redis的发布订阅功能**

Redis提供了基于“发布订阅”模式的消息机制，在这种模式下，消息发布者和订阅者不直接通信，发布者客户端向指定的频道发布消息，订阅该冰岛的每个客户端都可以收到该消息。

- 发布消息

  `publish channel message`

- 订阅消息

  `subscribe channel [频道名称]`

- 取消订阅

  `unsubscribe [频道名称]`

Redis的消息队列系统比专业的消息队列系统还差很多，但是足够的简单

**9. GEO**

GEO的全称是地理信息(经纬度)定位，支持存储地理位置信息来实现如附近的人，摇一摇这类依赖于地理位置信息的功能。

***

#### 4. 客户端

**1. java中如何操作redis**

jedis

***

#### 5. 持久化

https://juejin.im/post/5d09a9ff51882577eb133aa9

**1. 什么是持久化机制**

redis的数据是存放在内存中，由于内存的特点是断电后数据丢失，而redis需要保证redis服务器重启后数据还在，所以需要一种机制，这种机制就是持久化机制，他可以把数据持久化到物理磁盘中人，然后重启后从磁盘中读取数据恢复内存中的数据。

**2. Redis中有哪些持久化机制，默认是哪种**

Redis支持两种持久化机制，RDB和AOF，默认开启的是RDB

**3. 介绍一下RDB**

`RDB`是一种快照存储持久化方式，具体就是将`Redis`某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为`dump.rdb`，而在`Redis`服务器启动时，会重新加载`dump.rdb`文件的数据到内存当中恢复数据。

**4. 怎么开启RDB**

可以使用命令`save`和`bgsave`,两者的区别是`save`命令会阻塞Redis服务器直到rdb完成，而`bgsave`会fork一个子进程来处理不会发生阻塞。也可以通过服务器配置文件来配置触发rdb的条件

**5. 有哪些配置触发rdb条件的配置参数**

```java
# 900s内至少达到一条写命令
save 900 1
# 300s内至少到达10条写命令
save 300 10
# 60s内至少达到10000条写命令
save 60 10000
```

**4. 生成rdb文件的过程**

1. 生成临时rdb文件，并写入数据
2. 完成数据写入，用临时文件替代正式rdb文件
3. 删除原来的rdb文件

**5. rdb的优点**

1. 与AOF方式想比，通过rdb文件恢复数据比较快
2. rdb文件非常紧凑，适合数据备份
3. 通过rdb进行数据备份，由于使用了子进程，所以对redis服务器的性能影响比较小

**6. rdb的几个缺点**

- 如果服务器宕机的话，采用`RDB`的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。

- 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。

- 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。

**7. 什么是AOF**

`AOF`持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以`Redis`协议追加保存到以后缀为`aof`文件末尾，在Redis服务器重启时，会加载并运行`aof`文件的命令，以达到恢复数据的目的。

**8. 如何开启AOF持久化方式**

Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件

```properties
# 开启aof机制
appendonly yes

# aof文件名
appendfilename "appendonly.aof"

# 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no
appendfsync always

# 默认不重写aof文件
no-appendfsync-on-rewrite no

# 保存目录
dir ~/redis/
```

**9. 有哪些AOF的写入策略**

通过`appendfsync`来配置，可以取三个值

- always

  客户端的每一个写操作都保存到`aof`文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。

- everysec

  `appendfsync`的默认写入策略，每秒写入一次`aof`文件，因此，最多可能会丢失1s的数据。

- no

  `Redis`服务器不负责写入`aof`，而是交由操作系统来处理什么时候写入`aof`文件。更快，但也是最不安全的选择，不推荐使用。

**10.AOF文件太大了这么办**

可以进行AOF重写，通过重写在aof文件中只保存命令的最小集

**11. 重写的作用是什么**

aof不进行重写的话会有很多冗余的命令，这会使得aof越来越大，加载aof文件进行恢复时会很慢，重写aof文件的目的就是加快恢复的速度。

**12. 有哪些重写方式**

第一章是每次同步aof内容时就会发生重写，另一种是只要客户端向服务端发送bgrewriteaof命令的时候才会发生重写。

**13. AOF文件损坏了怎么办**

在写入aof日志文件时，如果Redis服务器宕机，则aof日志文件文件会出格式错误，在重启Redis服务器时，Redis服务器会拒绝载入这个aof文件，可以通过以下步骤修复aof并恢复数据。

1. 备份现在aof文件，以防万一。
2. 使用redis-check-aof命令修复aof文件，该命令格式`redis-check-aof -fix file.aof`

**14. AOF的优点**

AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。

**15. AOF的缺点**

1. AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。
2. 恢复数据的速度比RDB慢。

**16. AOF和RDB的对比**

| 方式       | RDB      | AOF          |
| ---------- | -------- | ------------ |
| 启动优先级 | 低       | 高           |
| 体积       | 小       | 大           |
| 恢复速度   | 快       | 慢           |
| 数据安全性 | 会丢数据 | 由策略来决定 |
| 轻重       | 重       | 轻           |

**17. rdb和aof同时开启的情况下，先使用哪种机制**

当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。

***

#### 6. 复制

**1. redis复制功能的作用**

如果使用一台redis服务器来保存数据，当这个服务器不可用的时候，整个服务就会不可用，为了解决这个问题，可以通过提供相同数据的多个副本，这样当一个节点不可用，整个服务并不受影响，后续可以将不可用的服务器恢复。

**2. 如何建立复制**

参与复制的结点可以分为主节点和从节点，默认情况下redis都是主节点，并且每个从节点只能有一个主节点，一个主节点可以有多个从节点，复制的数据是单向的，只能由主节点复制到从节点，配置的方式有三种

- 在配置文件中加入slaveof 主节点host，主节点port
- 在redis服务器启动命令后加--slaveof 主节点host，主节点port
- redis服务器启动使用命令slaveof 主节点host，主节点port

**3. 如何断开复制**

在从节点中执行`slaveof no one`命令，之后这个从节点将晋升为主节点

**4. 怎么保证主从复制的安全性**

对于数据比较重要的节点，主节点会通过设置`requirepass`参数进行密码验证，这时所有的客户端访问必须使用`auth`命令实行校验。

**5. 从节点可以进行写操作吗**

默认情况下，从节点使用slave-read-only=yes配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。

**6. 有哪些主从复制的拓扑结构，他们都有哪些特点**

**一主一从结构**是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。**一主多从结构**（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。**树状主从结构**（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量

**7. 主从复制的原理，复制过程是怎么样的**

执行slaveof命令，从节点先保存主节点的ip和端口信息，然后从节点会与主节点建立网络连接，连接成功之后从节点会发生ping请求进行首次通信，主节点会返回pong命令。如果主节点设置了权限认证则需要认证权限，认证完之后就可以进行数据集的同步，首次建立连接，主节点会把所有的数据全部发送个从节点，之后如果主节点有新的数据，会将命令持续复制给从节点，保证主从数据的一致性。

**8. 如何实现数据同步**

通过psync命令来完成主从数据同步，同步过程有两种，全量复制和部分复制

**9. 什么是全量复制，什么是部分复制**

**全量复制**一般用于初次复制场景，它会把主节点全部数据一次性发送个从节点。他的缺点是当数据流比较大时，对主从节点和网络会造成很大的开销。**部分复制**是用来处理主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从接待您，因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。

**10. psync命令需要哪些组件的支持**

主从节点各自的复制偏移量，主从节点复制积压缓冲区，主节点运行id。

- 复制偏移量

  参与复制的主从节点都会维护自身复制偏移量。主节点（master）在处理完写入命令后，会把命令的字节长度做累加记录，从节点（slave）每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量，从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量，通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。判断主从节点复制相差的数据量，根据这个差值判定当前复制的健康度。如果主从之间复制偏移量相差较大，则可能是网络延迟或命令阻塞等原因引起

- 复制积压缓冲区

  复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区。由于缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救

- 运行id

  每个Redis节点启动后都会动态分配一个**40位的十六进制字符串**作为运行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。

**11. fsync命令的流程**

- 从节点（slave）发送psync命令给主节点，参数runId是当前从节点保存的主节点运行ID，如果没有则默认值为，参数offset是当前从节点保存的复制偏移量，如果是第一次参与复制则默认值为-1。
- 主节点（master）根据psync参数和自身数据情况决定响应结果
  - 如果回复+FULLRESYNC{runId}{offset}，那么从节点将触发全量复制流程
  - 如果回复+CONTINUE，从节点将触发部分复制流程。
  - 如果回复+ERR，说明主节点版本低于Redis2.8，无法识别psync命令

**12. 全量复制的流程**

- 发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。
- 主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。
- 从节点接收主节点的响应数据保存运行ID和偏移量offset
- 主节点执行bgsave保存RDB文件到本地（也可以使用无盘复制不用保存到本地）
- 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件
- 对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性
- 从节点接收完主节点传送来的全部数据后会清空自身旧数据
- 从节点清空数据后开始加载RDB文件
- 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能，它会立刻做bgrewriteaof操作

**13. 部分复制的流程**

- 当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接
- 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB
- 当主从节点网络恢复后，从节点会再次连上主节点
- 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作
- 主节点接到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。
- 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态

**10. 主从机制的心跳机制**

- 主从节点彼此都有心跳检测机制，各自模拟成对方的客户端进行通信
- 主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。
- 从节点在主线程中每隔1秒发送replconf ack{offset}命令，给主节点上报自身当前的复制偏移量
- 主节点根据replconf命令判断从节点超时时间，体现在info replication统计中的lag信息中，lag表示与从节点最后一次通信延迟的秒数，正常延迟应该在0和1之间。如果超过repl-timeout配置的值（默认60秒），则判定从节点下线并断开复制客户端连接。即使主节点判定从节点下线后，如果从节点重新恢复，心跳检测会继续进行

**11. 什么是异步复制**

主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。

**12. 什么是读写分离**

对于读占比较高的场景，可以通过把一部分读流量分摊到从节点来减轻主节点压力，同时需要注意永远只对主节点执行写操作。

**13. 读写分离要注意什么问题**

·复制数据延迟、读到过期数据、从节点故障

- 复制数据延迟

  Redis复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。

- 读到过期数据

  当主节点存储大量设置超时的数据时，如缓存数据，Redis内部需要维护过期数据删除策略，删除策略主要有两种：惰性删除和定时删除。

  - 惰性删除

    主节点每次处理读取命令时，都会检查键是否超时，如果超时则执行del命令删除键对象，之后del命令也会异步发送给从节点，为了保证复制的一致性，从节点自身永远不会主动删除超时数据。

  - 定时删除

    Redis主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行del命令，之后再同步给从节点。

- 从节点故障

  对于从节点的故障问题，需要在客户端维护可用从节点列表，当从节点故障时立刻切换到其他从节点或主节点上。

**14. 什么时候会发生全量复制**

全量复制是一个非常消耗资源的操作，发生全量复制的时机有

- 第一次建立复制
- 节点运行ID不匹配
- 复制积压缓冲区不足

**15. 什么是复制风暴，如何规避复制风暴**

复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。复制风暴对发起复制的主节点或者机器造成大量开销，导致CPU、内存、带宽消耗。

应该把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点。当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。

***

#### 7. Redis的噩梦：阻塞

***

#### 8. 理解内存

***

#### 9. 哨兵

https://juejin.im/post/5b7d226a6fb9a01a1e01ff64

**1. 什么是redis哨兵**

Redis的主从复制模式下，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，对于很多应用场景这种故障处理的方式是无法接受的。当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。

**2. redis主从复制带来的问题**

Redis主从复制模式下，一旦主节点出现了故障不可达，需要人工干预进行故障转移，无论对于Redis的应用方还是运维方都带来了很大的不便。对于应用方来说无法及时感知到主节点的变化，必然会造成一定的写数据丢失和读数据错误，甚至可能造成应用方服务不可用。对于Redis的运维方来说，整个故障转移的过程是需要人工来介的，故障转移实时性和准确性上都无法得到保障。

**3. redis哨兵方案**

Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。整个过程完全是自动的，不需要人工
来介入

**4. redis哨兵如何监控节点的**

Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控

- 每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构
- 每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。
- 每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达

**5. 什么是主观下线**

每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。

**6. 什么是客观下线**

当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel ismaster-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定，这样客观下线的含义是比较明显了，也就是大部分Sentinel节点都对主节点的下线做了同意的判定，那么这个判定就是客观的。

**7. 如何进行领导的选举**

假如Sentinel节点对于主节点已经做了客观下线，那么是不是就可以立即进行故障转移了？当然不是，实际上故障转移的工作只需要一个Sentinel节点来完成即可，所以Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。

- 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。
- 收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinelis-master-down-by-addr命令，将同意该请求，否则拒绝。
- 如果该Sentinel节点发现自己的票数已经大于等于max（quorum，num（sentinels）/2+1），那么它将成为领导者。
- 如果此过程没有选举出领导者，将进入下一次选举。

**8. 故障转移是如何实现的**

1. 在从节点列表中选出一个节点作为新的主节点，选择方法如下
   - 过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。
   - 选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。
   - 选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。
   - 选择runid最小的从节点。

2. Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点

3. Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点
4. Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点

***

#### 10. 集群

**1. Redis集群是如何决定数据存放在哪台主机中的**

redis使用虚拟槽来进行分区的，首先规定槽的范围为0到16384，槽是集群内数据管理和迁移的基本单位，采用大范围槽的主要目的是为了方便树拆分和集群扩展。每个节点会负责一定数量的槽。所有的键通过哈希算法映射到0到16384整数槽中，计算公式为`slot=CRC16(key)&16383`

**2. 虚拟槽的特点**

- 解耦了数据与节点之间的关系，简化了节点扩容和收缩的难度
- 节点自身维护槽的映射关系，不需要客户端或代理服务维护槽分区
- 支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景

**3. redis集群功能有什么限制**

- 对key的批量操作支持有限
- key事务操作支持有
- key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点
- 不支持多数据库空间
- 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。

**4. 如何搭建集群**

一种是手动方式，一种是通过ruby脚本来实现

- 首先准备节点，节点的个数最少为6个，通过配置参数开启集群模式
  - 节点启动成功后会检查是否存在集群配置文件，如果没有会自动创建一份。
  - 当集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会自动保存集群状态到配置文件中。需要注意的是，Redis自动维护集群配置文件，不要手动修改，防止节点重启时产生集群信息错乱
  - 集群中的每一个节点使用一个40位长度的16进制字符串的节点id表示，这个id与运行id不同.节点ID在集群初始化时只创建一次，节点重启时会加载集群配置文件进行重用，而Redis的运行ID每次重启都会变化
- 通过节点握手让6个节点彼此建立联系从而组成一个集群
  - 节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程
  - 节点握手是集群彼此通信的第一步，由客户端发起命令：`cluster meet{ip}{port}`
  - 我们只需要在集群内任意节点上执行cluster meet命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程。最后执行cluster nodes命令确认6个节点都彼此感知并组成集群
  - 节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止
- Redis集群把所有的数据映射到16384个槽中
  - 每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令
- 每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移,使用cluster
  replicate{nodeId}命令让一个节点成为从节点

**5. 集群中节点通信的流程**

Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。

**6. 常用的Gossip消息有哪些**

- **meet消息**：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换
- **ping消息**：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据
- **pong消息**：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新
- **fail消息**：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。

**7. Gossip协议如何选择通信的节点**

集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong
消息的时间大于cluster_node_timeout/2，则立刻发送ping消息，防止该节点信息太长时间未更新。每次消息头的大小为2kb

**8. 集群伸缩的原理**

集群伸缩=槽和数据在节点之间的移动

**9. 如何扩容集群**

- 准备新节点

  需要提前准备好新节点并运行在集群模式下，新节点建议跟集群内的节点配置保持一致，便于管理统一

- 加入集群

  新节点依然采用cluster meet命令加入到现有集群中

- 迁移槽和数据

  槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。迁移计划需要确保每个节点负责相似数量的槽，从而保证各节点的数据均匀

**10. 如何收缩集群**

- 首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性
- 当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭

**11. 什么是集群的故障转移**

Redis集群自身实现了高可用。高可用首先需要解决集群部分失败的场景：当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。

**12. 集群如何发现故障**

当集群内某个节点出现问题时，需要通过一种健壮的方式保证识别出节点是否发生了故障。Redis集群内节点通过ping/pong消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障
等。因此故障发现也是通过消息传播机制实现的。

**13. 集群如何标记主观下线**

集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态

**14. 集群如何标记客观下线**

当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。ping/pong消息的消息体会携带集群1/10的其他节点状态数据，当接受节点发现消息体中含有主观下线的节点状态时，会在本地找到故障节
点的ClusterNode结构，保存到下线报告链表中.

通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当半数以上持有槽的主节点都标记某个节点是主观下线时。

**15. 为什么必须是负责槽的主节点参与故障发现决策**

因为集群模式下只有处理槽的主节点才负责读写请求和集群槽等关键信息维护，而从节点只进行主节点数据和状态信息的复制。

**16. 为什么半数以上处理槽的主节点**

必须半数以上是为了应对网络分区等原因造成的集群分割情况，被分割的小集群因为无法完成从主观下线到
客观下线这一关键过程，从而防止小集群完成故障转移之后继续对外提供服务。

**17. 如何进行故障转移**

故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用.

- **资格检查**：每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。如果从节点与主节点断线时间超过cluster-node-time*cluster-slave-validity-factor，则当前从节点不具备故障转移资格。参数cluster-slavevalidity-factor用于从节点的有效因子，默认为10。
- **准备选举时间**：当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程
- **发起选举**：当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程
  - **更新配置纪元**：配置纪元是一个只增不减的整数，每个主节点自身维护一个配置纪标示当前主节点的版本，所有主节点的配置纪元都不相等，从节点会复制主节点的配置纪元。
- **选举投票**

****

***

#### 11. 缓存设计

**1. 缓存带来了哪些收益**

- 加速读写

  缓存通常是基于内存的，读写性能非常高。

- 降低后端负载

  帮助后端减少访问量和复杂计算（例如很复杂的SQL语句），在很大程度降低了后端的负载。

**2. 缓存带来了哪些成本**

- 数据不一致性：缓存层和存储层的数据存在着一定时间窗口的不一致性，时间窗口跟更新策略有关。
- 代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本。
- 运维成本：以Redis Cluster为例，加入后无形中增加了运维成本。

**3. 什么场景应该使用缓存**

开销大的复杂计算：以MySQL为例子，一些复杂的操作或者计算（例如大量联表操作、一些分组计算），如果不加缓存，不但无法满足高并发量，同时也会给MySQL带来巨大的负担。

加速请求响应：即使查询单条后端数据足够快（例如select*from table where id=），那么依然可以使用缓存，以Redis为例子，每秒可以完成数万次读写，并且提供的批量操作可以优化整个IO链的响应时间。

**4. 什么是缓存穿透**

缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。缓存穿透问题可能会使后端存储负载加大，由于很多后端存储不具备高并发性，甚至可能造成后端存储宕掉。

**5. 为什么会发生缓存穿透**

- 自身业务代码或者数据出现问题

- 一些恶意攻击、爬虫等造成大量空命中。下面我们来看一下如何解决缓存穿透问题

**6. 如何优化缓存穿透问题**

- 当存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。

- 使用布隆过滤器进行拦截

**7. 什么是无底洞现象**

添加新的节点，性能没有上升反而下降，这种现象称为无底洞现象

**8. 无底洞现象是怎么产生的**

键值数据库由于通常采用哈希函数将key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。

**9. 无底洞现象怎么优化**

**10. 什么是缓存雪崩**

由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。

**11. 如何优化缓存雪崩**

**12. 什么是缓存击穿**

**13. 如何优化缓存击穿**



***

*参考：《Redis开发与运维》*

**（未完待续）**



 