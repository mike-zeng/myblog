---
title: InnoDB锁总结
sidebar: [grid, toc, tags] # 放置任何你想要显示的侧边栏部件
categories: [数据库, mysql]
date: 2019-12-26
tags:
- 数据库
- mysql
- InnoDB
- 数据库锁
---



##### 1. 什么是锁，为什么要加锁

锁是一种用来实现对共享资源安全访问的工具，当多个用户并发地存取数据时，在数据库中就可能会产生多个事务同时操作同一行数据的情况，若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据的一致性。

##### 2. InnoDB锁的类型

![img](https://severinblog-1257009269.cos.ap-guangzhou.myqcloud.com/InnoDB%E9%94%81%E6%80%BB%E7%BB%93/image-202001302035.jpg)

- **按照锁的粒度来分**

  - 表锁

    MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率越高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。

  - 行锁

    Mysql中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

  - 页锁

- **按照锁算法来分**

  - Recodrd Lock
  - Gap Lock
  - Next-key Lock

- **按照加锁机制来分**

  - 乐观锁

    乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务；

  - 悲观锁

    悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁；

- **按照兼容性来分**

  - 共享锁

    共享锁（**Share Locks**，简记为S锁）又称为**读锁**。其它事务可以并发地读取数据，可以再加共享锁，但任何事务都不能获取数据上的排它锁，直至已经释放所有共享锁。

  - 排他锁

    排它锁（**Exclusive lock**，简记为X锁）又称为**写锁**。若事务对数据对象加上了排它锁，则只允许该事务对数据对象进行读取和修改，其它事务不能再对数据对象加任何类型的锁，直到该事务释放对象上的排它锁。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

  - 意向锁

    为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**。

    - 意向共享锁（IS）

      表示事务准备给数据行加入共享锁，事务在给一个数据行加共享锁之前必须先取得该表的IS锁。

    - 意向排它锁（IX）

      表示事务准备给数据行加入排它锁，事务在给一个数据行加排它锁之前必须先取得该表的IX锁。

##### 3. 一些锁的细节

- 意向锁的细节

  MySQL中表锁和行锁共存，若不引入意向锁，该如何判断是否锁冲突呢？

  假设事务T要对表T1加X锁，那就必须要判断T1表下每一个数据行是否加了S锁或者X锁。这样做的效率会非常低，需要对整个表进行遍历。在引入意向锁之后情况变得简单了。

  假设事务T要对表T1加X锁，在这之前假设已经有事务A对数据行R加了S锁，那么此时表上已经有IS锁了（事务在给一个数据行加S锁之前必须先取得该表的IS锁）。由于X锁和IS锁冲突，所以事务T需要等待锁操作完成。这样就省去了遍历的操作，提高了冲突判断效率。

  - 意向锁是表锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。

  - IX和IS是表锁，不会与行锁发生冲突，只会与表锁发生冲突。

- 有哪些锁算法

  - Record Lock

    记录锁，锁定一个行记录。

    由于InnoDB特殊的索引机制，数据库操作使用主键索引时，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引

  - Gap Lock

    间隙锁，锁定一个区间，不包括记录本身

  - Next-Key Lock

    记录锁+间隙锁（临键锁），锁定行记录和区间

    InnoDB引擎采用Next-Key Lock来解决幻读问题。因为Next-Key Lock是锁住一个范围，所以就不会产生幻读问题。但是需要注意的是，InnoDB只在Repeatable Read隔离级别下使用该机制。